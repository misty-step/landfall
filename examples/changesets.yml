# Release pipeline using Changesets for versioning
# and Landfall for user-facing note synthesis.
#
# How it works:
#   1. Developers add changeset files via `npx changeset`
#   2. changesets/action opens a "Version Packages" PR collecting pending changesets
#   3. Merging that PR publishes packages and creates GitHub Releases
#   4. Landfall synthesizes user-facing notes for the new release
#
# Requirements:
#   - Repository secrets: GH_RELEASE_TOKEN, OPENROUTER_API_KEY
#   - Changesets initialized in repo (`npx changeset init`)
#   - publish script that creates GitHub Releases (e.g., `changeset tag`)
#
# Docs:
#   - Changesets: https://github.com/changesets/changesets
#   - changesets/action: https://github.com/changesets/action
#   - Landfall: https://github.com/misty-step/landfall

name: Release

on:
  push:
    branches: [main]

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      published: ${{ steps.changesets.outputs.published }}
      published_packages: ${{ steps.changesets.outputs.publishedPackages }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 22

      - run: npm ci

      - name: Create release PR or publish
        id: changesets
        uses: changesets/action@v1
        with:
          # Your publish command. Should create GitHub Releases
          # for Landfall to find and enhance.
          publish: npm run release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

  synthesize:
    needs: release
    if: needs.release.outputs.published == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: write
      issues: write
    steps:
      - uses: actions/checkout@v4

      # Extract version from the first published package.
      # Adjust the tag format (v{version}) to match your convention.
      - name: Resolve release tag
        id: tag
        env:
          PUBLISHED_PACKAGES: ${{ needs.release.outputs.published_packages }}
        run: |
          tag=$(echo "${PUBLISHED_PACKAGES}" \
            | python3 -c "import sys,json; print('v' + json.load(sys.stdin)[0]['version'])")
          echo "name=${tag}" >> "${GITHUB_OUTPUT}"

      - uses: misty-step/landfall@v1
        with:
          mode: synthesis-only
          release-tag: ${{ steps.tag.outputs.name }}
          github-token: ${{ secrets.GH_RELEASE_TOKEN }}
          llm-api-key: ${{ secrets.OPENROUTER_API_KEY }}
          # Optional: customize synthesis behavior.
          # audience: developer
          # changelog-source: release-body

# Monorepo variant: if changesets publishes multiple packages,
# use a matrix strategy to synthesize notes for each release.
#
#   synthesize:
#     needs: release
#     if: needs.release.outputs.published == 'true'
#     runs-on: ubuntu-latest
#     strategy:
#       matrix:
#         package: ${{ fromJson(needs.release.outputs.published_packages) }}
#     steps:
#       - uses: actions/checkout@v4
#       - uses: misty-step/landfall@v1
#         with:
#           mode: synthesis-only
#           release-tag: "${{ matrix.package.name }}@${{ matrix.package.version }}"
#           github-token: ${{ secrets.GH_RELEASE_TOKEN }}
#           llm-api-key: ${{ secrets.OPENROUTER_API_KEY }}
