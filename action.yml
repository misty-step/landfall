name: Landfall
description: Focused release pipeline using semantic-release with optional LLM-powered synthesis.

inputs:
  mode:
    description: "Pipeline mode: 'full' (semantic-release + synthesis), 'synthesis-only' (synthesize for existing tag)."
    default: "full"
    required: false
  release-tag:
    description: Release tag to synthesize notes for (required when mode is synthesis-only).
    default: ""
    required: false
  github-token:
    description: Personal access token with repository write access.
    required: true
  llm-api-key:
    description: API key for LLM synthesis (OpenRouter, OpenAI, or any compatible provider).
    required: false
  llm-model:
    description: Primary model ID for synthesis (e.g., 'anthropic/claude-sonnet-4', 'openai/gpt-4o-mini').
    default: anthropic/claude-sonnet-4
    required: false
  llm-fallback-models:
    description: Comma-separated fallback model IDs tried in order if primary fails.
    default: "google/gemini-2.5-flash,openai/gpt-4o-mini"
    required: false
  llm-api-url:
    description: Chat completions endpoint URL (OpenAI-compatible).
    default: "https://openrouter.ai/api/v1/chat/completions"
    required: false
  node-version:
    description: Node.js version for semantic-release.
    default: "22"
    required: false
  synthesis:
    description: Whether to synthesize user-facing release notes.
    default: "true"
    required: false
  synthesis-required:
    description: Whether synthesis and release-body update failures should fail the action.
    default: "false"
    required: false
  synthesis-strict:
    description: Deprecated alias for synthesis-required.
    default: "false"
    required: false
  synthesis-failure-issue:
    description: Whether to create a GitHub issue in the consuming repository when synthesis fails.
    default: "true"
    required: false
  notes-output-file:
    description: Write synthesized notes to this file path. Use {version} placeholder for the release tag (e.g., 'docs/releases/{version}.md').
    default: ""
    required: false
  notes-output-text-file:
    description: Write synthesized notes as plaintext to this file path. Use {version} placeholder (e.g., 'docs/releases/{version}.txt').
    default: ""
    required: false
  notes-output-html-file:
    description: Write synthesized notes as an HTML fragment to this file path. Use {version} placeholder (e.g., 'docs/releases/{version}.html').
    default: ""
    required: false
  notes-output-json:
    description: Append a structured release entry to this JSON array file. Creates the file if it does not exist.
    default: ""
    required: false
  prompt-template-path:
    description: Path to a custom synthesis prompt template (relative to repo root). Overrides convention-based detection (.landfall/synthesis-prompt.md).
    default: ""
    required: false
  healthcheck:
    description: Validate LLM API key with a minimal probe request before synthesis. Catches stale or revoked keys early.
    default: "false"
    required: false
  floating-tags:
    description: Update floating major version tags (e.g., v1) after release. Recommended for GitHub Actions repos.
    default: "false"
    required: false

outputs:
  released:
    description: Whether a release was created (full mode) or targeted (synthesis-only mode).
    value: ${{ steps.resolve_release.outputs.released }}
  release-tag:
    description: Release tag (created by semantic-release in full mode, or from input in synthesis-only mode).
    value: ${{ steps.resolve_release.outputs.release_tag }}
  synthesis-succeeded:
    description: Whether synthesis and release body update completed successfully.
    value: ${{ steps.synthesis_result.outputs.succeeded }}
  release-notes:
    description: Synthesized user-facing release notes markdown. Empty if synthesis was skipped or failed.
    value: ${{ steps.write_artifacts.outputs.notes }}

runs:
  using: composite
  steps:
    - name: Setup Node.js
      if: inputs.mode != 'synthesis-only'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"

    - name: Install Node dependencies
      if: inputs.mode != 'synthesis-only'
      shell: bash
      working-directory: ${{ github.action_path }}
      run: |
        set -euo pipefail
        npm ci --no-fund --no-audit

    - name: Install Python dependencies
      shell: bash
      run: |
        set -euo pipefail
        python -m pip install --upgrade pip
        python -m pip install requests

    - name: Validate LLM API key
      if: inputs.healthcheck == 'true' && inputs.llm-api-key != ''
      shell: bash
      run: |
        set -euo pipefail
        python "${GITHUB_ACTION_PATH}/scripts/healthcheck.py" \
          --api-key "${{ inputs.llm-api-key }}" \
          --model "${{ inputs.llm-model }}" \
          --api-url "${{ inputs.llm-api-url }}"

    - name: Run semantic-release
      id: semantic_release
      if: inputs.mode != 'synthesis-only'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        GH_TOKEN: ${{ inputs.github-token }}
      run: |
        set -euo pipefail

        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

        # Detect consumer-provided semantic-release config
        sr_extends_arg="--extends ${GITHUB_ACTION_PATH}/configs/.releaserc.json"
        for config_file in .releaserc .releaserc.json .releaserc.yml .releaserc.yaml \
                           release.config.js release.config.cjs release.config.mjs; do
          if [ -f "${GITHUB_WORKSPACE}/${config_file}" ]; then
            echo "::notice::Using repo semantic-release config: ${config_file}"
            sr_extends_arg=""
            break
          fi
        done

        before_tags="$(mktemp)"
        after_tags="$(mktemp)"
        git tag | sort > "${before_tags}"

        # shellcheck disable=SC2086
        npx --yes --prefix "${GITHUB_ACTION_PATH}" semantic-release \
          ${sr_extends_arg}

        git tag | sort > "${after_tags}"
        new_tag="$(comm -13 "${before_tags}" "${after_tags}" | tail -n1 || true)"

        if [ -n "${new_tag}" ]; then
          echo "released=true" >> "${GITHUB_OUTPUT}"
          echo "release_tag=${new_tag}" >> "${GITHUB_OUTPUT}"
        else
          echo "released=false" >> "${GITHUB_OUTPUT}"
          echo "release_tag=" >> "${GITHUB_OUTPUT}"
        fi

    - name: Resolve release context
      id: resolve_release
      shell: bash
      env:
        MODE: ${{ inputs.mode }}
        INPUT_RELEASE_TAG: ${{ inputs.release-tag }}
        SR_RELEASED: ${{ steps.semantic_release.outputs.released }}
        SR_RELEASE_TAG: ${{ steps.semantic_release.outputs.release_tag }}
      run: |
        set -euo pipefail
        if [ "${MODE}" = "synthesis-only" ]; then
          if [ -z "${INPUT_RELEASE_TAG}" ]; then
            echo "::error::release-tag input is required when mode is synthesis-only"
            exit 1
          fi
          echo "released=true" >> "${GITHUB_OUTPUT}"
          echo "release_tag=${INPUT_RELEASE_TAG}" >> "${GITHUB_OUTPUT}"
        else
          echo "released=${SR_RELEASED}" >> "${GITHUB_OUTPUT}"
          echo "release_tag=${SR_RELEASE_TAG}" >> "${GITHUB_OUTPUT}"
        fi

    - name: Update floating major tag
      id: update_floating_tag
      if: inputs.floating-tags == 'true' && steps.resolve_release.outputs.released == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        set -euo pipefail

        release_tag="${{ steps.resolve_release.outputs.release_tag }}"
        major_tag="$(python "${GITHUB_ACTION_PATH}/scripts/update-floating-tag.py" --release-tag "${release_tag}")"
        sha="$(git rev-list -n 1 "${release_tag}")"

        echo "Updating floating tag ${major_tag} â†’ ${sha}"
        git tag -f "${major_tag}" "${sha}"
        git push origin "refs/tags/${major_tag}" --force

    - name: Synthesize user-facing notes
      id: synthesize
      if: inputs.synthesis == 'true' && steps.resolve_release.outputs.released == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        PROMPT_TEMPLATE_PATH: ${{ inputs.prompt-template-path }}
      run: |
        set -euo pipefail

        sanitize_text() {
          printf '%s' "$1" | tr '\r\n' ' ' | sed -E 's/[[:space:]]+/ /g' | sed -E 's/^ +| +$//g'
        }

        set_output() {
          local key="$1"
          local value="$2"
          printf '%s=%s\n' "${key}" "${value}" >> "${GITHUB_OUTPUT}"
        }

        notes_file="${RUNNER_TEMP}/landfall-whats-new.md"
        product_name="${GITHUB_REPOSITORY#*/}"
        api_key="${{ inputs.llm-api-key }}"

        set_output "succeeded" "false"
        set_output "notes_file" ""
        set_output "failure_stage" ""
        set_output "failure_message" ""

        if [ -z "${api_key}" ]; then
          message="Landfall synthesis skipped; llm-api-key is empty."
          echo "::warning::${message}"
          set_output "failure_stage" "configuration"
          set_output "failure_message" "$(sanitize_text "${message}")"
          exit 0
        fi

        # Resolve changelog source: prefer CHANGELOG.md on disk, fall back to
        # the GitHub release body (which contains the same conventional-commits
        # notes generated by semantic-release).
        changelog_arg="--changelog-file ${GITHUB_WORKSPACE}/CHANGELOG.md"
        if [ ! -f "${GITHUB_WORKSPACE}/CHANGELOG.md" ]; then
          release_tag="${{ steps.resolve_release.outputs.release_tag }}"
          fallback_file="${RUNNER_TEMP}/landfall-release-body.md"
          if curl -sSf \
            -H "Authorization: token ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${release_tag}" \
            | python -c "import sys, json; print(json.load(sys.stdin).get('body', ''))" \
            > "${fallback_file}" 2>/dev/null && [ -s "${fallback_file}" ]; then
            changelog_arg="--technical-changelog-file ${fallback_file}"
          fi
        fi

        # Resolve prompt template: explicit input > convention > bundled default
        prompt_template="${GITHUB_ACTION_PATH}/templates/synthesis-prompt.md"
        if [ -n "${PROMPT_TEMPLATE_PATH}" ]; then
          custom_path="${GITHUB_WORKSPACE}/${PROMPT_TEMPLATE_PATH}"
          if [ ! -f "${custom_path}" ]; then
            echo "::error::Custom prompt template not found: ${PROMPT_TEMPLATE_PATH}"
            exit 1
          fi
          prompt_template="${custom_path}"
          echo "::notice::Using custom prompt template: ${PROMPT_TEMPLATE_PATH}"
        elif [ -f "${GITHUB_WORKSPACE}/.landfall/synthesis-prompt.md" ]; then
          prompt_template="${GITHUB_WORKSPACE}/.landfall/synthesis-prompt.md"
          echo "::notice::Using repo prompt template: .landfall/synthesis-prompt.md"
        fi

        synth_log="${RUNNER_TEMP}/landfall-synthesize.log"
        if ! python "${GITHUB_ACTION_PATH}/scripts/synthesize.py" \
          --api-key "${api_key}" \
          --model "${{ inputs.llm-model }}" \
          --api-url "${{ inputs.llm-api-url }}" \
          --fallback-models "${{ inputs.llm-fallback-models }}" \
          --product-name "${product_name}" \
          --version "${{ steps.resolve_release.outputs.release_tag }}" \
          ${changelog_arg} \
          --prompt-template "${prompt_template}" \
          > "${notes_file}" \
          2> "${synth_log}"; then
          details="$(tail -n 5 "${synth_log}" | tr '\r\n' ' ' | sed -E 's/[[:space:]]+/ /g' | sed -E 's/^ +| +$//g')"
          message="Landfall synthesis failed; publishing release without a What's New section."
          if [ -n "${details}" ]; then
            message="${message} Details: ${details}"
          fi
          message="$(sanitize_text "${message}")"
          echo "::warning::${message}"
          set_output "failure_stage" "synthesis"
          set_output "failure_message" "${message}"
          exit 0
        fi

        if [ ! -s "${notes_file}" ]; then
          message="Landfall synthesis returned empty notes; skipping release update."
          echo "::warning::${message}"
          set_output "failure_stage" "synthesis_empty"
          set_output "failure_message" "$(sanitize_text "${message}")"
          exit 0
        fi

        set_output "succeeded" "true"
        set_output "notes_file" "${notes_file}"

    - name: Update release body
      id: update_release
      if: inputs.synthesis == 'true' && steps.resolve_release.outputs.released == 'true'
      shell: bash
      env:
        SYNTH_STEP_SUCCEEDED: ${{ steps.synthesize.outputs.succeeded }}
        SYNTH_FAILURE_STAGE: ${{ steps.synthesize.outputs.failure_stage }}
        SYNTH_FAILURE_MESSAGE: ${{ steps.synthesize.outputs.failure_message }}
      run: |
        set -euo pipefail

        sanitize_text() {
          printf '%s' "$1" | tr '\r\n' ' ' | sed -E 's/[[:space:]]+/ /g' | sed -E 's/^ +| +$//g'
        }

        set_output() {
          local key="$1"
          local value="$2"
          printf '%s=%s\n' "${key}" "${value}" >> "${GITHUB_OUTPUT}"
        }

        set_output "succeeded" "false"
        set_output "failure_stage" ""
        set_output "failure_message" ""

        if [ "${SYNTH_STEP_SUCCEEDED}" != "true" ]; then
          stage="${SYNTH_FAILURE_STAGE}"
          message="${SYNTH_FAILURE_MESSAGE}"
          if [ -z "${stage}" ]; then
            stage="synthesis"
          fi
          if [ -z "${message}" ]; then
            message="Release body update skipped because synthesis did not succeed."
          fi
          set_output "failure_stage" "$(sanitize_text "${stage}")"
          set_output "failure_message" "$(sanitize_text "${message}")"
          exit 0
        fi

        update_log="${RUNNER_TEMP}/landfall-update-release.log"
        if ! python "${GITHUB_ACTION_PATH}/scripts/update-release.py" \
          --github-token "${{ inputs.github-token }}" \
          --repository "${GITHUB_REPOSITORY}" \
          --tag "${{ steps.resolve_release.outputs.release_tag }}" \
          --notes-file "${{ steps.synthesize.outputs.notes_file }}" \
          > /dev/null \
          2> "${update_log}"; then
          details="$(tail -n 5 "${update_log}" | tr '\r\n' ' ' | sed -E 's/[[:space:]]+/ /g' | sed -E 's/^ +| +$//g')"
          message="Landfall could not update the release body; release remains published."
          if [ -n "${details}" ]; then
            message="${message} Details: ${details}"
          fi
          message="$(sanitize_text "${message}")"
          echo "::warning::${message}"
          set_output "failure_stage" "release_update"
          set_output "failure_message" "${message}"
          exit 0
        fi

        set_output "succeeded" "true"

    - name: Write release notes artifacts
      id: write_artifacts
      if: inputs.synthesis == 'true' && steps.resolve_release.outputs.released == 'true' && steps.synthesize.outputs.succeeded == 'true'
      shell: bash
      run: |
        set -euo pipefail

        notes=""
        if [ -f "${{ steps.synthesize.outputs.notes_file }}" ]; then
          notes_output="$(python "${GITHUB_ACTION_PATH}/scripts/write-artifacts.py" \
            --notes-file "${{ steps.synthesize.outputs.notes_file }}" \
            --version "${{ steps.resolve_release.outputs.release_tag }}" \
            --output-file "${{ inputs.notes-output-file }}" \
            --output-text-file "${{ inputs.notes-output-text-file }}" \
            --output-html-file "${{ inputs.notes-output-html-file }}" \
            --output-json "${{ inputs.notes-output-json }}")" || true
          if [ -n "${notes_output}" ]; then
            notes="${notes_output}"
          fi
        fi

        {
          echo "notes<<LANDFALL_NOTES_EOF"
          echo "${notes}"
          echo "LANDFALL_NOTES_EOF"
        } >> "${GITHUB_OUTPUT}"

    - name: Summarize synthesis status
      id: synthesis_result
      shell: bash
      env:
        SYNTHESIS_ENABLED: ${{ inputs.synthesis }}
        RELEASED: ${{ steps.resolve_release.outputs.released }}
        SYNTH_STEP_SUCCEEDED: ${{ steps.synthesize.outputs.succeeded }}
        UPDATE_STEP_SUCCEEDED: ${{ steps.update_release.outputs.succeeded }}
        SYNTH_FAILURE_STAGE: ${{ steps.synthesize.outputs.failure_stage }}
        SYNTH_FAILURE_MESSAGE: ${{ steps.synthesize.outputs.failure_message }}
        UPDATE_FAILURE_STAGE: ${{ steps.update_release.outputs.failure_stage }}
        UPDATE_FAILURE_MESSAGE: ${{ steps.update_release.outputs.failure_message }}
      run: |
        set -euo pipefail

        set_output() {
          local key="$1"
          local value="$2"
          printf '%s=%s\n' "${key}" "${value}" >> "${GITHUB_OUTPUT}"
        }

        succeeded="false"
        failure_stage=""
        failure_message=""

        if [ "${SYNTHESIS_ENABLED}" = "true" ] && [ "${RELEASED}" = "true" ]; then
          if [ "${SYNTH_STEP_SUCCEEDED}" = "true" ] && [ "${UPDATE_STEP_SUCCEEDED}" = "true" ]; then
            succeeded="true"
          else
            failure_stage="${SYNTH_FAILURE_STAGE}"
            failure_message="${SYNTH_FAILURE_MESSAGE}"
            if [ -z "${failure_stage}" ] && [ -n "${UPDATE_FAILURE_STAGE}" ]; then
              failure_stage="${UPDATE_FAILURE_STAGE}"
              failure_message="${UPDATE_FAILURE_MESSAGE}"
            fi
            if [ -z "${failure_stage}" ]; then
              failure_stage="unknown"
            fi
            if [ -z "${failure_message}" ]; then
              failure_message="Landfall synthesis did not complete successfully."
            fi
          fi
        fi

        set_output "succeeded" "${succeeded}"
        set_output "failure_stage" "${failure_stage}"
        set_output "failure_message" "${failure_message}"

    - name: Report synthesis failure
      if: inputs.synthesis == 'true' && steps.resolve_release.outputs.released == 'true' && inputs.synthesis-failure-issue == 'true' && steps.synthesis_result.outputs.succeeded != 'true'
      shell: bash
      env:
        FAILURE_STAGE: ${{ steps.synthesis_result.outputs.failure_stage }}
        FAILURE_MESSAGE: ${{ steps.synthesis_result.outputs.failure_message }}
      run: |
        set -euo pipefail
        run_url="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
        if ! python "${GITHUB_ACTION_PATH}/scripts/report-synthesis-failure.py" \
          --github-token "${{ inputs.github-token }}" \
          --repository "${GITHUB_REPOSITORY}" \
          --release-tag "${{ steps.resolve_release.outputs.release_tag }}" \
          --workflow-run-url "${run_url}" \
          --workflow-name "${GITHUB_WORKFLOW}" \
          --failure-stage "${FAILURE_STAGE}" \
          --failure-message "${FAILURE_MESSAGE}"; then
          echo "::warning::Landfall could not create a synthesis failure issue."
        fi

    - name: Enforce synthesis required
      if: inputs.synthesis == 'true' && steps.resolve_release.outputs.released == 'true'
      shell: bash
      env:
        SYNTHESIS_REQUIRED: ${{ inputs.synthesis-required }}
        SYNTHESIS_STRICT: ${{ inputs.synthesis-strict }}
        SYNTHESIS_SUCCEEDED: ${{ steps.synthesis_result.outputs.succeeded }}
        FAILURE_STAGE: ${{ steps.synthesis_result.outputs.failure_stage }}
        FAILURE_MESSAGE: ${{ steps.synthesis_result.outputs.failure_message }}
      run: |
        set -euo pipefail
        if [ "${SYNTHESIS_REQUIRED}" != "true" ] && [ "${SYNTHESIS_STRICT}" != "true" ]; then
          exit 0
        fi
        if [ "${SYNTHESIS_SUCCEEDED}" = "true" ]; then
          exit 0
        fi
        echo "::error::Landfall synthesis required but failed at stage '${FAILURE_STAGE}'. ${FAILURE_MESSAGE}"
        exit 1
