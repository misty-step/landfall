name: Landfall
description: Focused release pipeline using semantic-release with optional LLM-powered synthesis.

inputs:
  mode:
    description: "Pipeline mode: 'full' (semantic-release + synthesis), 'synthesis-only' (synthesize for existing tag)."
    default: "full"
    required: false
  release-tag:
    description: Release tag to synthesize notes for (required when mode is synthesis-only).
    default: ""
    required: false
  github-token:
    description: Personal access token with repository write access.
    required: true
  llm-api-key:
    description: API key for LLM synthesis (OpenRouter, OpenAI, or any compatible provider).
    required: false
  llm-model:
    description: Primary model ID for synthesis (e.g., 'anthropic/claude-sonnet-4', 'openai/gpt-4o-mini').
    default: anthropic/claude-sonnet-4
    required: false
  llm-fallback-models:
    description: Comma-separated fallback model IDs tried in order if primary fails.
    default: "google/gemini-2.5-flash,openai/gpt-4o-mini"
    required: false
  llm-api-url:
    description: Chat completions endpoint URL (OpenAI-compatible).
    default: "https://openrouter.ai/api/v1/chat/completions"
    required: false
  node-version:
    description: Node.js version for semantic-release.
    default: "22"
    required: false
  synthesis:
    description: Whether to synthesize user-facing release notes.
    default: "true"
    required: false
  synthesis-required:
    description: Whether synthesis failures should fail the action. When true, a failed LLM key validation (healthcheck) also blocks the run before the release is published.
    default: "false"
    required: false
  synthesis-strict:
    description: Deprecated alias for synthesis-required.
    default: "false"
    required: false
  synthesis-failure-issue:
    description: Whether to create a GitHub issue in the consuming repository when synthesis fails.
    default: "false"
    required: false
  notes-output-file:
    description: Write synthesized notes to this file path. Use {version} placeholder for the release tag (e.g., 'docs/releases/{version}.md').
    default: ""
    required: false
  notes-output-text-file:
    description: Write synthesized notes as plaintext to this file path. Use {version} placeholder (e.g., 'docs/releases/{version}.txt').
    default: ""
    required: false
  notes-output-html-file:
    description: Write synthesized notes as an HTML fragment to this file path. Use {version} placeholder (e.g., 'docs/releases/{version}.html').
    default: ""
    required: false
  notes-output-json:
    description: Append a structured release entry to this JSON array file. Creates the file if it does not exist.
    default: ""
    required: false
  prompt-template-path:
    description: Path to a custom synthesis prompt template (relative to repo root). Overrides audience and convention-based detection (.landfall/synthesis-prompt.md).
    default: ""
    required: false
  audience:
    description: Built-in synthesis prompt variant used when no custom prompt template is found. One of general, developer, end-user, enterprise.
    default: "general"
    required: false
  product-description:
    description: One-line product description injected into the synthesis prompt as {{PRODUCT_CONTEXT}}.
    default: ""
    required: false
  voice-guide:
    description: Tone/style guidance injected into the synthesis prompt as {{VOICE_GUIDE}}.
    default: ""
    required: false
  changelog-source:
    description: Technical source for synthesis. One of auto (CHANGELOG.md > release body > PRs), changelog, release-body, prs.
    default: "auto"
    required: false
  healthcheck:
    description: Validate LLM API key with a minimal probe request before synthesis. Catches stale or revoked keys early.
    default: "false"
    required: false
  floating-tags:
    description: Update floating major version tags (e.g., v1) after release. Recommended for GitHub Actions repos.
    default: "false"
    required: false
  webhook-url:
    description: Webhook endpoint URL. On synthesis success, POST a JSON payload with version, notes (markdown/HTML/plaintext), and release URL.
    default: ""
    required: false
  webhook-secret:
    description: HMAC-SHA256 secret for signing webhook payloads (X-Signature-256 header). Optional.
    default: ""
    required: false
  slack-webhook-url:
    description: Slack Incoming Webhook URL. On synthesis success, POST a Block Kit message with version, categorized notes, and release link.
    default: ""
    required: false
  rss-feed-file:
    description: Path to an RSS 2.0 feed file to update on release (e.g., 'docs/releases.xml'). The file is committed back to the repo.
    default: ""
    required: false
  rss-max-entries:
    description: Maximum number of RSS entries to retain in the feed file.
    default: "50"
    required: false

outputs:
  released:
    description: Whether a release was created (full mode) or targeted (synthesis-only mode).
    value: ${{ steps.resolve_release.outputs.released }}
  release-tag:
    description: Release tag (created by semantic-release in full mode, or from input in synthesis-only mode).
    value: ${{ steps.resolve_release.outputs.release_tag }}
  synthesis-succeeded:
    description: Whether synthesis and release body update completed successfully.
    value: ${{ steps.synthesis_result.outputs.succeeded }}
  release-notes:
    description: Synthesized user-facing release notes markdown. Empty if synthesis was skipped or failed.
    value: ${{ steps.write_artifacts.outputs.notes }}
  synthesis-quality:
    description: "Quality of synthesized output: valid (passed validation), degraded (validation failed, using unvalidated output), or failed (synthesis itself failed)."
    value: ${{ steps.synthesis_result.outputs.quality }}
  webhook-sent:
    description: Whether the webhook notification was sent successfully.
    value: ${{ steps.notify_webhook.outputs.sent || 'false' }}
  slack-sent:
    description: Whether the Slack notification was sent successfully.
    value: ${{ steps.notify_slack.outputs.sent || 'false' }}

runs:
  using: composite
  steps:
    - name: Setup Node.js
      if: inputs.mode != 'synthesis-only'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"

    - name: Install Node dependencies
      if: inputs.mode != 'synthesis-only'
      shell: bash
      working-directory: ${{ github.action_path }}
      run: |
        set -euo pipefail
        npm ci --no-fund --no-audit

    - name: Install Python dependencies
      shell: bash
      run: |
        set -euo pipefail
        python -m pip install --upgrade pip
        python -m pip install requests

    - name: Validate LLM API key
      if: (inputs.synthesis == 'true' || inputs.healthcheck == 'true') && inputs.llm-api-key != ''
      shell: bash
      env:
        LLM_API_KEY: ${{ inputs.llm-api-key }}
        LLM_MODEL: ${{ inputs.llm-model }}
        LLM_API_URL: ${{ inputs.llm-api-url }}
        SYNTHESIS_REQUIRED: ${{ inputs.synthesis-required }}
      run: |
        set -euo pipefail
        WARN_ONLY_ARGS=()
        if [ "${SYNTHESIS_REQUIRED}" != "true" ]; then
          WARN_ONLY_ARGS=(--warn-only)
        fi
        python "${GITHUB_ACTION_PATH}/scripts/healthcheck.py" \
          --api-key "${LLM_API_KEY}" \
          --model "${LLM_MODEL}" \
          --api-url "${LLM_API_URL}" \
          "${WARN_ONLY_ARGS[@]}"

    - name: Preflight tag history check
      if: inputs.mode != 'synthesis-only'
      shell: bash
      run: |
        set -euo pipefail
        git fetch --tags --force 2>/dev/null || true
        python "${GITHUB_ACTION_PATH}/scripts/preflight-tags.py"

    - name: Run semantic-release
      id: semantic_release
      if: inputs.mode != 'synthesis-only'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        GH_TOKEN: ${{ inputs.github-token }}
      run: |
        set -euo pipefail

        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

        # Detect consumer-provided semantic-release config
        sr_extends_arg="--extends ${GITHUB_ACTION_PATH}/configs/.releaserc.json"
        for config_file in .releaserc .releaserc.json .releaserc.yml .releaserc.yaml \
                           release.config.js release.config.cjs release.config.mjs; do
          if [ -f "${GITHUB_WORKSPACE}/${config_file}" ]; then
            echo "::notice::Using repo semantic-release config: ${config_file}"
            sr_extends_arg=""
            break
          fi
        done

        before_tags="$(mktemp)"
        after_tags="$(mktemp)"
        git tag | sort > "${before_tags}"

        # shellcheck disable=SC2086
        npx --yes --prefix "${GITHUB_ACTION_PATH}" semantic-release \
          ${sr_extends_arg}

        git tag | sort > "${after_tags}"
        new_tag="$(comm -13 "${before_tags}" "${after_tags}" | tail -n1 || true)"

        if [ -n "${new_tag}" ]; then
          echo "released=true" >> "${GITHUB_OUTPUT}"
          echo "release_tag=${new_tag}" >> "${GITHUB_OUTPUT}"
        else
          echo "released=false" >> "${GITHUB_OUTPUT}"
          echo "release_tag=" >> "${GITHUB_OUTPUT}"
        fi

    - name: Resolve release context
      id: resolve_release
      shell: bash
      env:
        MODE: ${{ inputs.mode }}
        INPUT_RELEASE_TAG: ${{ inputs.release-tag }}
        SR_RELEASED: ${{ steps.semantic_release.outputs.released }}
        SR_RELEASE_TAG: ${{ steps.semantic_release.outputs.release_tag }}
      run: |
        set -euo pipefail
        if [ "${MODE}" = "synthesis-only" ]; then
          if [ -z "${INPUT_RELEASE_TAG}" ]; then
            echo "::error::release-tag input is required when mode is synthesis-only"
            exit 1
          fi
          echo "released=true" >> "${GITHUB_OUTPUT}"
          echo "release_tag=${INPUT_RELEASE_TAG}" >> "${GITHUB_OUTPUT}"
        else
          echo "released=${SR_RELEASED}" >> "${GITHUB_OUTPUT}"
          echo "release_tag=${SR_RELEASE_TAG}" >> "${GITHUB_OUTPUT}"
        fi

    - name: Synthesize user-facing notes
      id: synthesize
      if: inputs.synthesis == 'true' && steps.resolve_release.outputs.released == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        LLM_API_KEY: ${{ inputs.llm-api-key }}
        LLM_MODEL: ${{ inputs.llm-model }}
        LLM_API_URL: ${{ inputs.llm-api-url }}
        LLM_FALLBACK_MODELS: ${{ inputs.llm-fallback-models }}
        RELEASE_TAG: ${{ steps.resolve_release.outputs.release_tag }}
        PROMPT_TEMPLATE_PATH: ${{ inputs.prompt-template-path }}
        AUDIENCE: ${{ inputs.audience }}
        CHANGELOG_SOURCE: ${{ inputs.changelog-source }}
        PRODUCT_DESCRIPTION: ${{ inputs.product-description }}
        VOICE_GUIDE: ${{ inputs.voice-guide }}
      run: |
        set -euo pipefail

        sanitize_text() {
          printf '%s' "$1" | tr '\r\n' ' ' | sed -E 's/[[:space:]]+/ /g' | sed -E 's/^ +| +$//g'
        }

        set_output() {
          local key="$1"
          local value="$2"
          printf '%s=%s\n' "${key}" "${value}" >> "${GITHUB_OUTPUT}"
        }

        notes_file="${RUNNER_TEMP}/landfall-whats-new.md"
        product_name="${GITHUB_REPOSITORY#*/}"
        api_key="${LLM_API_KEY}"
        product_description="${PRODUCT_DESCRIPTION}"
        voice_guide="${VOICE_GUIDE}"

        set_output "succeeded" "false"
        set_output "notes_file" ""
        set_output "failure_stage" ""
        set_output "failure_message" ""

        if [ -z "${api_key}" ]; then
          message="Landfall synthesis skipped; llm-api-key is empty."
          echo "::warning::${message}"
          set_output "failure_stage" "configuration"
          set_output "failure_message" "$(sanitize_text "${message}")"
          exit 0
        fi

        changelog_source="$(printf '%s' "${CHANGELOG_SOURCE}" | tr '[:upper:]' '[:lower:]')"
        case "${changelog_source}" in
          auto|changelog|release-body|prs) ;;
          *)
            message="Invalid changelog-source '${CHANGELOG_SOURCE}'. Expected one of: auto, changelog, release-body, prs."
            echo "::warning::${message}"
            set_output "failure_stage" "configuration"
            set_output "failure_message" "$(sanitize_text "${message}")"
            exit 0
            ;;
        esac

        release_tag="${RELEASE_TAG}"
        changelog_file="${GITHUB_WORKSPACE}/CHANGELOG.md"
        release_body_file=""
        pr_changelog_file=""

        fetch_release_body() {
          local target_file="$1"
          curl -sSf \
            -H "Authorization: token ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${release_tag}" \
            | python -c "import sys, json; print(json.load(sys.stdin).get('body', ''))" \
            > "${target_file}" 2>/dev/null && [ -s "${target_file}" ]
        }

        build_pr_changelog() {
          local target_file="$1"
          python "${GITHUB_ACTION_PATH}/scripts/extract-prs.py" \
            --github-token "${GITHUB_TOKEN}" \
            --repository "${GITHUB_REPOSITORY}" \
            --release-tag "${release_tag}" \
            --output-file "${target_file}" \
            > /dev/null \
            2> "${RUNNER_TEMP}/landfall-extract-prs.log"
        }

        has_changelog_file="false"
        if [ -s "${changelog_file}" ]; then
          has_changelog_file="true"
        fi

        if [ "${changelog_source}" = "release-body" ] || [ "${changelog_source}" = "auto" ]; then
          if [ "${changelog_source}" = "release-body" ] || [ "${has_changelog_file}" != "true" ]; then
            candidate_release_body="${RUNNER_TEMP}/landfall-release-body.md"
            if fetch_release_body "${candidate_release_body}"; then
              release_body_file="${candidate_release_body}"
            fi
          fi
        fi

        if [ "${changelog_source}" = "prs" ] || [ "${changelog_source}" = "auto" ]; then
          should_extract_prs="false"
          if [ "${changelog_source}" = "prs" ]; then
            should_extract_prs="true"
          elif [ "${has_changelog_file}" != "true" ] && [ -z "${release_body_file}" ]; then
            should_extract_prs="true"
          fi

          if [ "${should_extract_prs}" = "true" ]; then
            candidate_pr_changelog="${RUNNER_TEMP}/landfall-pr-changelog.md"
            if build_pr_changelog "${candidate_pr_changelog}" && [ -s "${candidate_pr_changelog}" ]; then
              pr_changelog_file="${candidate_pr_changelog}"
            fi
          fi
        fi

        if [ "${changelog_source}" = "changelog" ] && [ "${has_changelog_file}" != "true" ]; then
          message="changelog-source is 'changelog' but CHANGELOG.md is missing or empty."
          echo "::warning::${message}"
          set_output "failure_stage" "configuration"
          set_output "failure_message" "$(sanitize_text "${message}")"
          exit 0
        fi

        if [ "${changelog_source}" = "release-body" ] && [ -z "${release_body_file}" ]; then
          message="changelog-source is 'release-body' but no release body was found for ${release_tag}."
          echo "::warning::${message}"
          set_output "failure_stage" "configuration"
          set_output "failure_message" "$(sanitize_text "${message}")"
          exit 0
        fi

        if [ "${changelog_source}" = "prs" ] && [ -z "${pr_changelog_file}" ]; then
          message="changelog-source is 'prs' but PR extraction returned no changelog content."
          echo "::warning::${message}"
          set_output "failure_stage" "configuration"
          set_output "failure_message" "$(sanitize_text "${message}")"
          exit 0
        fi

        # Resolve prompt template: explicit input > convention > bundled audience variant
        prompt_template=""
        if [ -n "${PROMPT_TEMPLATE_PATH}" ]; then
          custom_path="${GITHUB_WORKSPACE}/${PROMPT_TEMPLATE_PATH}"
          if [ ! -f "${custom_path}" ]; then
            echo "::error::Custom prompt template not found: ${PROMPT_TEMPLATE_PATH}"
            exit 1
          fi
          prompt_template="${custom_path}"
          echo "::notice::Using custom prompt template: ${PROMPT_TEMPLATE_PATH}"
        elif [ -f "${GITHUB_WORKSPACE}/.landfall/synthesis-prompt.md" ]; then
          prompt_template="${GITHUB_WORKSPACE}/.landfall/synthesis-prompt.md"
          echo "::notice::Using repo prompt template: .landfall/synthesis-prompt.md"
        else
          echo "::notice::Using built-in prompt template audience: ${AUDIENCE}"
        fi

        quality_file="${RUNNER_TEMP}/landfall-synthesis-quality.txt"
        synth_log="${RUNNER_TEMP}/landfall-synthesize.log"
        if ! python "${GITHUB_ACTION_PATH}/scripts/synthesize.py" \
          --api-key "${api_key}" \
          --model "${LLM_MODEL}" \
          --api-url "${LLM_API_URL}" \
          --fallback-models "${LLM_FALLBACK_MODELS}" \
          --product-name "${product_name}" \
          --product-description "${product_description}" \
          --voice-guide "${voice_guide}" \
          --audience "${AUDIENCE}" \
          --changelog-source "${changelog_source}" \
          --version "${release_tag}" \
          --changelog-file "${changelog_file}" \
          --release-body-file "${release_body_file}" \
          --pr-changelog-file "${pr_changelog_file}" \
          --prompt-template "${prompt_template}" \
          --quality-file "${quality_file}" \
          > "${notes_file}" \
          2> "${synth_log}"; then
          details="$(tail -n 5 "${synth_log}" | tr '\r\n' ' ' | sed -E 's/[[:space:]]+/ /g' | sed -E 's/^ +| +$//g')"
          message="Landfall synthesis failed; publishing release without a What's New section."
          if [ -n "${details}" ]; then
            message="${message} Details: ${details}"
          fi
          message="$(sanitize_text "${message}")"
          echo "::warning::${message}"
          set_output "failure_stage" "synthesis"
          set_output "failure_message" "${message}"
          exit 0
        fi

        if [ ! -s "${notes_file}" ]; then
          message="Landfall synthesis returned empty notes; skipping release update."
          echo "::warning::${message}"
          set_output "failure_stage" "synthesis_empty"
          set_output "failure_message" "$(sanitize_text "${message}")"
          exit 0
        fi

        quality="valid"
        if [ -f "${quality_file}" ]; then
          quality="$(cat "${quality_file}")"
        fi
        set_output "succeeded" "true"
        set_output "notes_file" "${notes_file}"
        set_output "quality" "${quality}"

    - name: Update release body
      id: update_release
      if: inputs.synthesis == 'true' && steps.resolve_release.outputs.released == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        SYNTH_STEP_SUCCEEDED: ${{ steps.synthesize.outputs.succeeded }}
        SYNTH_FAILURE_STAGE: ${{ steps.synthesize.outputs.failure_stage }}
        SYNTH_FAILURE_MESSAGE: ${{ steps.synthesize.outputs.failure_message }}
        RELEASE_TAG: ${{ steps.resolve_release.outputs.release_tag }}
        NOTES_FILE: ${{ steps.synthesize.outputs.notes_file }}
      run: |
        set -euo pipefail

        sanitize_text() {
          printf '%s' "$1" | tr '\r\n' ' ' | sed -E 's/[[:space:]]+/ /g' | sed -E 's/^ +| +$//g'
        }

        set_output() {
          local key="$1"
          local value="$2"
          printf '%s=%s\n' "${key}" "${value}" >> "${GITHUB_OUTPUT}"
        }

        set_output "succeeded" "false"
        set_output "failure_stage" ""
        set_output "failure_message" ""

        if [ "${SYNTH_STEP_SUCCEEDED}" != "true" ]; then
          stage="${SYNTH_FAILURE_STAGE}"
          message="${SYNTH_FAILURE_MESSAGE}"
          if [ -z "${stage}" ]; then
            stage="synthesis"
          fi
          if [ -z "${message}" ]; then
            message="Release body update skipped because synthesis did not succeed."
          fi
          set_output "failure_stage" "$(sanitize_text "${stage}")"
          set_output "failure_message" "$(sanitize_text "${message}")"
          exit 0
        fi

        update_log="${RUNNER_TEMP}/landfall-update-release.log"
        if ! python "${GITHUB_ACTION_PATH}/scripts/update-release.py" \
          --github-token "${GITHUB_TOKEN}" \
          --repository "${GITHUB_REPOSITORY}" \
          --tag "${RELEASE_TAG}" \
          --notes-file "${NOTES_FILE}" \
          > /dev/null \
          2> "${update_log}"; then
          details="$(tail -n 5 "${update_log}" | tr '\r\n' ' ' | sed -E 's/[[:space:]]+/ /g' | sed -E 's/^ +| +$//g')"
          message="Landfall could not update the release body; release remains published."
          if [ -n "${details}" ]; then
            message="${message} Details: ${details}"
          fi
          message="$(sanitize_text "${message}")"
          echo "::warning::${message}"
          set_output "failure_stage" "release_update"
          set_output "failure_message" "${message}"
          exit 0
        fi

        set_output "succeeded" "true"

    - name: Write release notes artifacts
      id: write_artifacts
      if: inputs.synthesis == 'true' && steps.resolve_release.outputs.released == 'true' && steps.synthesize.outputs.succeeded == 'true'
      shell: bash
      env:
        NOTES_FILE: ${{ steps.synthesize.outputs.notes_file }}
        RELEASE_TAG: ${{ steps.resolve_release.outputs.release_tag }}
        OUTPUT_FILE: ${{ inputs.notes-output-file }}
        OUTPUT_TEXT_FILE: ${{ inputs.notes-output-text-file }}
        OUTPUT_HTML_FILE: ${{ inputs.notes-output-html-file }}
        OUTPUT_JSON: ${{ inputs.notes-output-json }}
      run: |
        set -euo pipefail

        notes=""
        if [ -f "${NOTES_FILE}" ]; then
          notes_output="$(python "${GITHUB_ACTION_PATH}/scripts/write-artifacts.py" \
            --notes-file "${NOTES_FILE}" \
            --version "${RELEASE_TAG}" \
            --output-file "${OUTPUT_FILE}" \
            --output-text-file "${OUTPUT_TEXT_FILE}" \
            --output-html-file "${OUTPUT_HTML_FILE}" \
            --output-json "${OUTPUT_JSON}")" || true
          if [ -n "${notes_output}" ]; then
            notes="${notes_output}"
          fi
        fi

        {
          echo "notes<<LANDFALL_NOTES_EOF"
          echo "${notes}"
          echo "LANDFALL_NOTES_EOF"
        } >> "${GITHUB_OUTPUT}"

    - name: Update RSS feed file
      if: inputs.rss-feed-file != '' && steps.resolve_release.outputs.released == 'true' && steps.synthesize.outputs.succeeded == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        RSS_FEED_FILE: ${{ inputs.rss-feed-file }}
        RSS_MAX_ENTRIES: ${{ inputs.rss-max-entries }}
        RELEASE_TAG: ${{ steps.resolve_release.outputs.release_tag }}
        NOTES_FILE: ${{ steps.synthesize.outputs.notes_file }}
      run: |
        set -euo pipefail

        release_tag="${RELEASE_TAG}"
        release_url="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/releases/tag/${RELEASE_TAG}"

        python "${GITHUB_ACTION_PATH}/scripts/update-feed.py" \
          --feed-file "${RSS_FEED_FILE}" \
          --max-entries "${RSS_MAX_ENTRIES}" \
          --repository "${GITHUB_REPOSITORY}" \
          --release-tag "${release_tag}" \
          --release-url "${release_url}" \
          --notes-file "${NOTES_FILE}" \
          --workspace "${GITHUB_WORKSPACE}"

        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

        git add "${RSS_FEED_FILE}"
        if git diff --cached --quiet; then
          echo "::notice::RSS feed unchanged; skipping commit."
          exit 0
        fi

        git commit -m "chore(feed): update releases feed for ${release_tag} [skip ci]"
        git push origin "HEAD:${GITHUB_REF_NAME}"

    - name: Send webhook notification
      id: notify_webhook
      if: inputs.webhook-url != '' && steps.resolve_release.outputs.released == 'true' && steps.synthesize.outputs.succeeded == 'true'
      shell: bash
      env:
        WEBHOOK_URL: ${{ inputs.webhook-url }}
        WEBHOOK_SECRET: ${{ inputs.webhook-secret }}
        RELEASE_TAG: ${{ steps.resolve_release.outputs.release_tag }}
        NOTES_FILE: ${{ steps.synthesize.outputs.notes_file }}
      run: |
        set -euo pipefail

        set_output() {
          local key="$1"
          local value="$2"
          printf '%s=%s\n' "${key}" "${value}" >> "${GITHUB_OUTPUT}"
        }

        set_output "sent" "false"

        release_tag="${RELEASE_TAG}"
        release_url="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/releases/tag/${release_tag}"
        notes_file="${NOTES_FILE}"

        if [ ! -s "${notes_file}" ]; then
          echo "::warning::Webhook skipped: notes file is empty or missing."
          exit 0
        fi

        if python "${GITHUB_ACTION_PATH}/scripts/notify.py" \
          --webhook-url "${WEBHOOK_URL}" \
          --webhook-secret "${WEBHOOK_SECRET}" \
          --version "${release_tag}" \
          --repository "${GITHUB_REPOSITORY}" \
          --release-url "${release_url}" \
          --notes-file "${notes_file}"; then
          set_output "sent" "true"
        else
          echo "::warning::Webhook notification failed; release continues."
        fi

    - name: Send Slack notification
      id: notify_slack
      if: inputs.slack-webhook-url != '' && steps.resolve_release.outputs.released == 'true' && steps.synthesize.outputs.succeeded == 'true'
      shell: bash
      env:
        SLACK_WEBHOOK_URL: ${{ inputs.slack-webhook-url }}
        RELEASE_TAG: ${{ steps.resolve_release.outputs.release_tag }}
        NOTES_FILE: ${{ steps.synthesize.outputs.notes_file }}
      run: |
        set -euo pipefail

        set_output() {
          local key="$1"
          local value="$2"
          printf '%s=%s\n' "${key}" "${value}" >> "${GITHUB_OUTPUT}"
        }

        set_output "sent" "false"

        release_tag="${RELEASE_TAG}"
        release_url="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/releases/tag/${release_tag}"
        notes_file="${NOTES_FILE}"

        if [ ! -s "${notes_file}" ]; then
          echo "::warning::Slack notification skipped: notes file is empty or missing."
          exit 0
        fi

        if python "${GITHUB_ACTION_PATH}/scripts/notify-slack.py" \
          --version "${release_tag}" \
          --repository "${GITHUB_REPOSITORY}" \
          --release-url "${release_url}" \
          --notes-file "${notes_file}"; then
          set_output "sent" "true"
        else
          echo "::warning::Slack notification failed; release continues."
        fi

    - name: Summarize synthesis status
      id: synthesis_result
      shell: bash
      env:
        SYNTHESIS_ENABLED: ${{ inputs.synthesis }}
        RELEASED: ${{ steps.resolve_release.outputs.released }}
        SYNTH_STEP_SUCCEEDED: ${{ steps.synthesize.outputs.succeeded }}
        SYNTH_QUALITY: ${{ steps.synthesize.outputs.quality }}
        UPDATE_STEP_SUCCEEDED: ${{ steps.update_release.outputs.succeeded }}
        SYNTH_FAILURE_STAGE: ${{ steps.synthesize.outputs.failure_stage }}
        SYNTH_FAILURE_MESSAGE: ${{ steps.synthesize.outputs.failure_message }}
        UPDATE_FAILURE_STAGE: ${{ steps.update_release.outputs.failure_stage }}
        UPDATE_FAILURE_MESSAGE: ${{ steps.update_release.outputs.failure_message }}
      run: |
        set -euo pipefail

        set_output() {
          local key="$1"
          local value="$2"
          printf '%s=%s\n' "${key}" "${value}" >> "${GITHUB_OUTPUT}"
        }

        succeeded="false"
        failure_stage=""
        failure_message=""
        quality="failed"

        if [ "${SYNTHESIS_ENABLED}" = "true" ] && [ "${RELEASED}" = "true" ]; then
          if [ "${SYNTH_STEP_SUCCEEDED}" = "true" ] && [ "${UPDATE_STEP_SUCCEEDED}" = "true" ]; then
            succeeded="true"
            quality="${SYNTH_QUALITY:-valid}"
          else
            failure_stage="${SYNTH_FAILURE_STAGE}"
            failure_message="${SYNTH_FAILURE_MESSAGE}"
            if [ -z "${failure_stage}" ] && [ -n "${UPDATE_FAILURE_STAGE}" ]; then
              failure_stage="${UPDATE_FAILURE_STAGE}"
              failure_message="${UPDATE_FAILURE_MESSAGE}"
            fi
            if [ -z "${failure_stage}" ]; then
              failure_stage="unknown"
            fi
            if [ -z "${failure_message}" ]; then
              failure_message="Landfall synthesis did not complete successfully."
            fi
          fi
        fi

        set_output "succeeded" "${succeeded}"
        set_output "quality" "${quality}"
        set_output "failure_stage" "${failure_stage}"
        set_output "failure_message" "${failure_message}"

    - name: Update floating major tag
      id: update_floating_tag
      if: inputs.floating-tags == 'true' && steps.resolve_release.outputs.released == 'true' && (inputs.synthesis != 'true' || inputs.synthesis-required != 'true' || steps.synthesis_result.outputs.succeeded == 'true')
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        RELEASE_TAG: ${{ steps.resolve_release.outputs.release_tag }}
      run: |
        set -euo pipefail

        release_tag="${RELEASE_TAG}"
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
        git fetch --tags --force

        major_tag="$(python "${GITHUB_ACTION_PATH}/scripts/update-floating-tag.py" --release-tag "${release_tag}")"
        if [ -z "${major_tag}" ]; then
          echo "::notice::Skipping floating tag update for pre-release tag ${release_tag}."
          exit 0
        fi
        sha="$(git rev-list -n 1 "${release_tag}")"

        echo "Updating floating tag ${major_tag} â†’ ${sha}"
        git tag -f "${major_tag}" "${sha}"
        git push origin "refs/tags/${major_tag}" --force

    - name: Close resolved synthesis failure issues
      if: inputs.synthesis == 'true' && steps.resolve_release.outputs.released == 'true' && inputs.synthesis-failure-issue == 'true' && steps.synthesis_result.outputs.succeeded == 'true'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        RELEASE_TAG: ${{ steps.resolve_release.outputs.release_tag }}
      run: |
        set -euo pipefail
        if ! python "${GITHUB_ACTION_PATH}/scripts/close-resolved-failures.py" \
          --github-token "${GITHUB_TOKEN}" \
          --repository "${GITHUB_REPOSITORY}" \
          --release-tag "${RELEASE_TAG}"; then
          echo "::warning::Landfall could not close resolved failure issues."
        fi

    - name: Report synthesis failure
      if: inputs.synthesis == 'true' && steps.resolve_release.outputs.released == 'true' && inputs.synthesis-failure-issue == 'true' && steps.synthesis_result.outputs.succeeded != 'true' && steps.synthesis_result.outputs.failure_stage != 'configuration'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        FAILURE_STAGE: ${{ steps.synthesis_result.outputs.failure_stage }}
        FAILURE_MESSAGE: ${{ steps.synthesis_result.outputs.failure_message }}
        RELEASE_TAG: ${{ steps.resolve_release.outputs.release_tag }}
      run: |
        set -euo pipefail
        run_url="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
        if ! python "${GITHUB_ACTION_PATH}/scripts/report-synthesis-failure.py" \
          --github-token "${GITHUB_TOKEN}" \
          --repository "${GITHUB_REPOSITORY}" \
          --release-tag "${RELEASE_TAG}" \
          --workflow-run-url "${run_url}" \
          --workflow-name "${GITHUB_WORKFLOW}" \
          --failure-stage "${FAILURE_STAGE}" \
          --failure-message "${FAILURE_MESSAGE}"; then
          echo "::warning::Landfall could not create a synthesis failure issue."
        fi

    - name: Enforce synthesis required
      if: inputs.synthesis == 'true' && steps.resolve_release.outputs.released == 'true'
      shell: bash
      env:
        SYNTHESIS_REQUIRED: ${{ inputs.synthesis-required }}
        SYNTHESIS_STRICT: ${{ inputs.synthesis-strict }}
        SYNTHESIS_SUCCEEDED: ${{ steps.synthesis_result.outputs.succeeded }}
        FAILURE_STAGE: ${{ steps.synthesis_result.outputs.failure_stage }}
        FAILURE_MESSAGE: ${{ steps.synthesis_result.outputs.failure_message }}
      run: |
        set -euo pipefail
        if [ "${SYNTHESIS_REQUIRED}" != "true" ] && [ "${SYNTHESIS_STRICT}" != "true" ]; then
          exit 0
        fi
        if [ "${SYNTHESIS_SUCCEEDED}" = "true" ]; then
          exit 0
        fi
        echo "::error::Landfall synthesis required but failed at stage '${FAILURE_STAGE}'. ${FAILURE_MESSAGE}"
        exit 1
